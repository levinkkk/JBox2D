/**
 * Created at 11:34:45 AM Jan 23, 2011
 */
package org.jbox2d.dynamics.joints;

import org.jbox2d.common.Vec2;
import org.jbox2d.dynamics.TimeStep;
import org.jbox2d.pooling.WorldPool;

//Gear Joint:
//C0 = (coordinate1 + ratio * coordinate2)_initial
//C = C0 - (cordinate1 + ratio * coordinate2) = 0
//Cdot = -(Cdot1 + ratio * Cdot2)
//J = -[J1 ratio * J2]
//K = J * invM * JT
//= J1 * invM1 * J1T + ratio * ratio * J2 * invM2 * J2T
//
//Revolute:
//coordinate = rotation
//Cdot = angularVelocity
//J = [0 0 1]
//K = J * invM * JT = invI
//
//Prismatic:
//coordinate = dot(p - pg, ug)
//Cdot = dot(v + cross(w, r), ug)
//J = [ug cross(r, ug)]
//K = J * invM * JT = invMass + invI * cross(r, ug)^2

/**
 * A gear joint is used to connect two joints together. Either joint
 * can be a revolute or prismatic joint. You specify a gear ratio
 * to bind the motions together:
 * coordinate1 + ratio * coordinate2 = constant
 * The ratio can be negative or positive. If one joint is a revolute joint
 * and the other joint is a prismatic joint, then the ratio will have units
 * of length or units of 1/length.
 * @warning The revolute and prismatic joints must be attached to
 * fixed bodies (which must be body1 on those joints).
 * @author Daniel Murphy
 */
public class GearJoint extends Joint {
	
	Body m_ground1;
	Body m_ground2;

	// One of these is null.
	RevoluteJoint m_revolute1;
	PrismaticJoint m_prismatic1;

	// One of these is null.
	RevoluteJoint m_revolute2;
	PrismaticJoint m_prismatic2;

	Vec2 m_groundAnchor1;
	Vec2 m_groundAnchor2;

	Vec2 m_localAnchor1;
	Vec2 m_localAnchor2;

	Jacobian m_J;

	float m_constant;
	float m_ratio;

	// Effective mass
	float m_mass;

	// Impulse for accumulation/warm starting.
	float m_impulse;
	
	/**
	 * @param argWorldPool
	 * @param def
	 */
	public GearJoint(WorldPool argWorldPool, GearJointDef def) {
		super(argWorldPool, def);
		
		JointType type1 = def.joint1.getType();
		JointType type2 = def.joint2.getType();

		Assert(type1 == e_revoluteJoint || type1 == e_prismaticJoint);
		Assert(type2 == e_revoluteJoint || type2 == e_prismaticJoint);
		Assert(def.joint1.getBodyA().getType() == _staticBody);
		Assert(def.joint2.getBodyA().getType() == _staticBody);

		m_revolute1 = null;
		m_prismatic1 = null;
		m_revolute2 = null;
		m_prismatic2 = null;

		float coordinate1, coordinate2;

		m_ground1 = def.joint1.getBodyA();
		m_bodyA = def.joint1.getBodyB();
		if (type1 == e_revoluteJoint)
		{
			m_revolute1 = (RevoluteJoint)def.joint1;
			m_groundAnchor1 = m_revolute1.m_localAnchor1;
			m_localAnchor1 = m_revolute1.m_localAnchor2;
			coordinate1 = m_revolute1.getJointAngle();
		}
		else
		{
			m_prismatic1 = (PrismaticJoint)def.joint1;
			m_groundAnchor1 = m_prismatic1.m_localAnchor1;
			m_localAnchor1 = m_prismatic1.m_localAnchor2;
			coordinate1 = m_prismatic1.getJointTranslation();
		}

		m_ground2 = def.joint2.getBodyA();
		m_bodyB = def.joint2.getBodyB();
		if (type2 == e_revoluteJoint)
		{
			m_revolute2 = (RevoluteJoint)def.joint2;
			m_groundAnchor2 = m_revolute2.m_localAnchor1;
			m_localAnchor2 = m_revolute2.m_localAnchor2;
			coordinate2 = m_revolute2.getJointAngle();
		}
		else
		{
			m_prismatic2 = (PrismaticJoint)def.joint2;
			m_groundAnchor2 = m_prismatic2.m_localAnchor1;
			m_localAnchor2 = m_prismatic2.m_localAnchor2;
			coordinate2 = m_prismatic2.getJointTranslation();
		}

		m_ratio = def.ratio;

		m_constant = coordinate1 + m_ratio * coordinate2;

		m_impulse = 0.0f;
	}
	
	/**
	 * @see org.jbox2d.dynamics.joints.Joint#getAnchorA(org.jbox2d.common.Vec2)
	 */
	@Override
	public void getAnchorA(new Vec2 argOut) {
		// TODO Auto-generated method stub
		
	}
	
	/**
	 * @see org.jbox2d.dynamics.joints.Joint#getAnchorB(org.jbox2d.common.Vec2)
	 */
	@Override
	public void getAnchorB(new Vec2 argOut) {
		// TODO Auto-generated method stub
		
	}
	
	/**
	 * @see org.jbox2d.dynamics.joints.Joint#getReactionForce(float, org.jbox2d.common.Vec2)
	 */
	@Override
	public void getReactionForce(float inv_dt, new Vec2 argOut) {
		// TODO Auto-generated method stub
		
	}
	
	/**
	 * @see org.jbox2d.dynamics.joints.Joint#getReactionTorque(float)
	 */
	@Override
	public float getReactionTorque(float inv_dt) {
		// TODO Auto-generated method stub
		return 0;
	}
	
	/**
	 * @see org.jbox2d.dynamics.joints.Joint#initVelocityConstraints(org.jbox2d.dynamics.TimeStep)
	 */
	@Override
	public void initVelocityConstraints(TimeStep step) {
		Body g1 = m_ground1;
		Body g2 = m_ground2;
		Body b1 = m_bodyA;
		Body  = m_bodyB;

		float K = 0.0f;
		m_J.setZero();

		if (m_revolute1)
		{
			m_J.angularA = -1.0f;
			K += b1.m_invI;
		}
		else
		{
			Vec2 ug = Mul(g1.getTransform().R, m_prismatic1.m_localXAxis1);
			Vec2 r = Mul(b1.getTransform().R, m_localAnchor1 - b1.getLocalCenter());
			float crug = Vec2.cross(r, ug);
			m_J.linearA = -ug;
			m_J.angularA = -crug;
			K += b1.m_invMass + b1.m_invI * crug * crug;
		}

		if (m_revolute2)
		{
			m_J.angularB = -m_ratio;
			K += m_ratio * m_ratio * .m_invI;
		}
		else
		{
			Vec2 ug = Mul(g2.getTransform().R, m_prismatic2.m_localXAxis1);
			Vec2 r = Mul(.getTransform().R, m_localAnchor2 - .getLocalCenter());
			float crug = Vec2.cross(r, ug);
			m_J.linearB = -m_ratio * ug;
			m_J.angularB = -m_ratio * crug;
			K += m_ratio * m_ratio * (.m_invMass + .m_invI * crug * crug);
		}

		// Compute effective mass.
		m_mass = K > 0.0f ? 1.0f / K : 0.0f;

		if (step.warmStarting)
		{
			// Warm starting.
			b1.m_linearVelocity += b1.m_invMass * m_impulse * m_J.linearA;
			b1.m_angularVelocity += b1.m_invI * m_impulse * m_J.angularA;
			.m_linearVelocity += .m_invMass * m_impulse * m_J.linearB;
			.m_angularVelocity += .m_invI * m_impulse * m_J.angularB;
		}
		else
		{
			m_impulse = 0.0f;
		}
	}
	
	/**
	 * @see org.jbox2d.dynamics.joints.Joint#solveVelocityConstraints(org.jbox2d.dynamics.TimeStep)
	 */
	@Override
	public void solveVelocityConstraints(TimeStep step) {
		Body b1 = m_bodyA;
		Body  = m_bodyB;

		float Cdot = m_J.Compute(	b1.m_linearVelocity, b1.m_angularVelocity,
									.m_linearVelocity, .m_angularVelocity);

		float impulse = m_mass * (-Cdot);
		m_impulse += impulse;

		b1.m_linearVelocity += b1.m_invMass * impulse * m_J.linearA;
		b1.m_angularVelocity += b1.m_invI * impulse * m_J.angularA;
		.m_linearVelocity += .m_invMass * impulse * m_J.linearB;
		.m_angularVelocity += .m_invI * impulse * m_J.angularB;
	}
	
	/**
	 * @see org.jbox2d.dynamics.joints.Joint#solvePositionConstraints(float)
	 */
	@Override
	public boolean solvePositionConstraints(float baumgarte) {
		float linearError = 0.0f;

		Body b1 = m_bodyA;
		Body  = m_bodyB;

		float coordinate1, coordinate2;
		if (m_revolute1)
		{
			coordinate1 = m_revolute1.getJointAngle();
		}
		else
		{
			coordinate1 = m_prismatic1.getJointTranslation();
		}

		if (m_revolute2)
		{
			coordinate2 = m_revolute2.getJointAngle();
		}
		else
		{
			coordinate2 = m_prismatic2.getJointTranslation();
		}

		float C = m_constant - (coordinate1 + m_ratio * coordinate2);

		float impulse = m_mass * (-C);

		b1.m_sweep.c += b1.m_invMass * impulse * m_J.linearA;
		b1.m_sweep.a += b1.m_invI * impulse * m_J.angularA;
		.m_sweep.c += .m_invMass * impulse * m_J.linearB;
		.m_sweep.a += .m_invI * impulse * m_J.angularB;

		b1.SynchronizeTransform();
		.SynchronizeTransform();

		// TODO_ERIN not implemented
		return linearError < Settings.linearSlop;
	}
	
}
